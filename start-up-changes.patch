diff --git a/ellipticoind/src/constants.rs b/ellipticoind/src/constants.rs
index 33c73b7..ef9501e 100644
--- a/ellipticoind/src/constants.rs
+++ b/ellipticoind/src/constants.rs
@@ -1,8 +1,8 @@
 use vm::zero_pad_vec;
 pub const SYSTEM_ADDRESS: [u8; 32] = [0; 32];
-// 3i5sXB1tP/yiftq6nl6wqLgGAdAnXml7hLuenYcln+8= in hex
+// vQMn3JvS3ATITteQ+gOYfuVSn2buuAH+4e8NY/CvtwA= in hex
 pub const GENISIS_ADRESS: [u8; 32] =
-    hex!("de2e6c5c1d6d3ffca27edaba9e5eb0a8b80601d0275e697b84bb9e9d87259fef");
+    hex!("bd0327dc9bd2dc04c84ed790fa03987ee5529f66eeb801fee1ef0d63f0afb700");
 lazy_static! {
     pub static ref TOKEN_CONTRACT: Vec<u8> =
         { [&SYSTEM_ADDRESS.to_vec(), "Ellipticoin".as_bytes()].concat() };
diff --git a/ellipticoind/src/schema.rs b/ellipticoind/src/schema.rs
index 106c4da..72e630a 100644
--- a/ellipticoind/src/schema.rs
+++ b/ellipticoind/src/schema.rs
@@ -34,4 +34,8 @@ table! {
 
 joinable!(transactions -> blocks (block_hash));
 
-allow_tables_to_appear_in_same_query!(blocks, hash_onion, transactions,);
+allow_tables_to_appear_in_same_query!(
+    blocks,
+    hash_onion,
+    transactions,
+);
diff --git a/ellipticoind/src/start_up.rs b/ellipticoind/src/start_up.rs
index c588a43..abe81a3 100644
--- a/ellipticoind/src/start_up.rs
+++ b/ellipticoind/src/start_up.rs
@@ -7,6 +7,7 @@ use std::fs::File;
 use std::io::Read;
 use std::path::Path;
 use vm::state::db_key;
+use std::io::BufRead;
 
 use crate::constants::{GENISIS_ADRESS, TOKEN_CONTRACT};
 use crate::diesel::ExpressionMethods;
@@ -37,7 +38,7 @@ lazy_static! {
 }
 
 pub fn generate_hash_onion(db: &PooledConnection<ConnectionManager<PgConnection>>) -> Vec<u8> {
-    let hash_onion_size = 1000;
+    let hash_onion_size = 65534;
     let center: Vec<u8> = rand::thread_rng()
         .sample_iter(&rand::distributions::Standard)
         .take(32)
@@ -76,6 +77,19 @@ pub fn sha256(value: Vec<u8>) -> Vec<u8> {
     hasher.result().to_vec()
 }
 
+fn read_n<R>(reader: R, bytes_to_read: u64) -> Vec<u8>
+where
+    R: Read,
+{
+    let mut buf = vec![];
+    let mut chunk = reader.take(bytes_to_read);
+    // Do appropriate error handling for your situation
+    // Maybe it's OK if you didn't read enough bytes?
+    let n = chunk.read_to_end(&mut buf).expect("Didn't read enough");
+    assert_eq!(bytes_to_read as usize, n);
+    buf
+}
+
 pub async fn initialize_rocks_db(
     path: &str,
     pg_db: &PooledConnection<ConnectionManager<PgConnection>>,
@@ -133,10 +147,25 @@ pub async fn initialize_rocks_db(
                 .progress_chars("=> "),
         );
         let mut batch = rocksdb::WriteBatch::default();
-        let mut buffer = Vec::new();
-        file.read_to_end(&mut buffer).unwrap();
-        let mut i = 0;
-        for chunk in buffer.chunks(24) {
+        //let mut i = 0;
+        //loop {
+        //let mut buffer = [0; 24];
+        //if file.read_exact(&mut chunk).is_err() {
+        //    file.read_to_end(&mut buffer)
+        //    break;
+        //}
+        //if bytes_read != 2400 {
+        //    pb.finish();
+        //    println!("oh shit! {}", bytes_read);
+        //    break
+        //}
+            const CAP: usize = 24 * 1000;
+    let mut reader = std::io::BufReader::with_capacity(CAP, file);
+
+    loop {
+        let length = {
+            let buffer = reader.fill_buf().unwrap();
+            for chunk in buffer.chunks(24) {
             batch.put(
                 db_key(
                     &TOKEN_CONTRACT,
@@ -144,15 +173,19 @@ pub async fn initialize_rocks_db(
                 ), // [ETHEREUM_BALANCE_PREFIX.to_vec(), chunk[0..20].to_vec()].concat()
                 chunk[20..24].to_vec(),
             );
-            if i % 1000 == 0 {
-                pb.inc(1000);
             }
-            i += 1
+            pb.inc(1000);
+            db.write(batch).unwrap();
+            batch = rocksdb::WriteBatch::default(); 
+            buffer.len()
+        };
+        if length == 0 {
+            break;
         }
+        reader.consume(length);
+    }
         pb.finish();
-        println!("Writing Ethereum balances to storage...");
 
-        db.write(batch).unwrap();
         let genesis_balance = db
             .get(db_key(
                 &TOKEN_CONTRACT,
@@ -164,6 +197,7 @@ pub async fn initialize_rocks_db(
             ))
             .unwrap()
             .unwrap();
+        println!("genesis_balance: {:?}", genesis_balance);
         db.delete(db_key(
             &TOKEN_CONTRACT,
             &[
